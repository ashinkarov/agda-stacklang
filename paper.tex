\documentclass[sigplan,screen]{acmart}

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}

\citestyle{acmauthoryear}   %% For author/year citations



%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

% Add definitions for abbreviations like e.g.; i.e; etc. with
% correct spacing depending on the parameters.  In this case
% `all' exposes all the definitions of the package, and `british'
% makes sure that there is no comma after e.g. or i.e.
\usepackage[all,british]{foreign}

\usepackage{epsf}
\usepackage{wrapfig}

\usepackage{mathpartir}

\usepackage{todonotes}

\usepackage{varwidth}
\usepackage{microtype}

\usepackage{agda}
\usepackage{newunicodechar}
\usepackage[final]{listings}
\lstset{
    basicstyle=\small,
}
\usepackage{microtype}

%\usepackage[T1]{fontenc}

\newunicodechar{∷}{::}
\newunicodechar{→}{\ensuremath{\to}}
\newunicodechar{ω}{\ensuremath{\omega}}
\newunicodechar{⊎}{\ensuremath{\uplus}}
\newunicodechar{≔}{\ensuremath{\coloneqq}}
\newunicodechar{∎}{\ensuremath{\blacksquare}}
\newunicodechar{≟}{\ensuremath{\stackrel{?}{=}}}
\newunicodechar{ᵣ}{\ensuremath{_r}}
\newunicodechar{ₗ}{\ensuremath{_l}}
\newunicodechar{▴}{\ensuremath{\blacktriangle}}
\newunicodechar{▾}{\ensuremath{\blacktriangledown}}
\newunicodechar{▹}{\ensuremath{\triangleright}}
\newunicodechar{∸}{\ensuremath{\dot{-}}}
\newunicodechar{⊛}{\ensuremath{\circledast}}
\newunicodechar{ᵀ}{\ensuremath{{}^{\text{T}}}}
\newunicodechar{⌿}{\ensuremath{\not-}}

\newunicodechar{←}{\ensuremath{\leftarrow}}
\newunicodechar{×}{\ensuremath{\times}}
\newunicodechar{λ}{\ensuremath{\lambda}}
\newunicodechar{∀}{\ensuremath{\forall}}
\newunicodechar{Π}{\ensuremath{\Pi}}
\newunicodechar{≡}{\ensuremath{\equiv}}
\newunicodechar{≅}{\ensuremath{\cong}}
\newunicodechar{≐}{\ensuremath{\doteq}}
\newunicodechar{∈}{\ensuremath{\in}}
\newunicodechar{∧}{\ensuremath{\land}}
\newunicodechar{∨}{\ensuremath{\lor}}
\newunicodechar{⊤}{\ensuremath{\top}}
\newunicodechar{⊥}{\ensuremath{\bot}}
\newunicodechar{⊔}{\ensuremath{\sqcup}}
\newunicodechar{∷}{\ensuremath{{::}}}
\newunicodechar{ℓ}{\ensuremath{\ell}}
\newunicodechar{₀}{\ensuremath{{_0}}}
\newunicodechar{₁}{\ensuremath{{_1}}}
\newunicodechar{₂}{\ensuremath{{_2}}}
\newunicodechar{₃}{\ensuremath{{_3}}}
\newunicodechar{₄}{\ensuremath{{_4}}}
\newunicodechar{₅}{\ensuremath{{_5}}}
\newunicodechar{₆}{\ensuremath{{_6}}}
\newunicodechar{₇}{\ensuremath{{_7}}}
\newunicodechar{₈}{\ensuremath{{_8}}}
\newunicodechar{₉}{\ensuremath{{_9}}}
\newunicodechar{⟨}{\ensuremath{{\langle}}}
\newunicodechar{⟩}{\ensuremath{{\rangle}}}
\newunicodechar{̧}{\c}
\newunicodechar{≤}{\ensuremath{\leq}}
\newunicodechar{ℕ}{\ensuremath{\mathbb{N}}}
\newunicodechar{∸}{̣\ensuremath{-}}
\newunicodechar{ᵇ}{\ensuremath{{}^{b}}}
\newunicodechar{✔}{\checkmark}

% Some shortcut commands for agda symbols
\newcommand{\AD}[1]{\AgdaDatatype{#1}}
\newcommand{\AC}[1]{\AgdaInductiveConstructor{#1}}
\newcommand{\AF}[1]{\AgdaFunction{#1}}
\newcommand{\AB}[1]{\AgdaBound{#1}}
\newcommand{\AK}[1]{\AgdaKeyword{#1}}
\newcommand{\AR}[1]{\AgdaField{#1}}
\newcommand{\AM}[1]{\AgdaModule{#1}}
\newcommand{\AN}[1]{\AgdaNumber{#1}}
\newcommand{\AS}[1]{\AgdaString{#1}}
\newcommand{\AMA}[1]{\AgdaMacro{#1}}

\newcommand{\hrefu}[2]{\href{#1}{\nolinkurl{#2}}}

\newcommand\codeblock[1]{%
  %{\fbox{\begin{varwidth}{0.9\textwidth}#1\end{varwidth}}}
  {\begin{varwidth}{0.9\textwidth}#1\end{varwidth}}
}

\renewcommand{\AgdaCommentFontStyle}[1]{\textsf{#1}}


\newcommand{\myref}[2]{\hyperref[#2]{#1~\ref*{#2}}}
\newcommand{\figref}[1]{\myref{Fig.}{fig:#1}}%{Fig.~\ref{fig:#1}}
\newcommand{\secref}[1]{\myref{Sect.}{sec:#1}}
\newcommand{\lemref}[1]{\myref{Lemma}{lem:#1}}
\newcommand{\thmref}[1]{\myref{Theorem}{thm:#1}}
\newcommand{\defref}[1]{\myref{Definition}{def:#1}}
\newcommand{\eqnref}[1]{\hyperref[#1]{(\ref{#1})}}



\begin{document}

%% Title information
\title[]{Extracting The Power of Dependent Types}


%% Author with single affiliation.
\author[A. {\v{S}}inkarovs]{Artjoms {\v{S}}inkarovs}
\orcid{0000-0003-3292-2985}
%\authornote{with author1 note}          %% \authornote is optional;
                                         %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{%
  \institution{Heriot-Watt University}   %% \institution is required
  \city{Edinburgh}
  \state{Scotland}
  \postcode{EH14 4AS}
  \country{UK}}
\email{a.sinkarovs@hw.ac.uk}             %% \email is recommended


%% Author with single affiliation.
\author[J. Cockx]{Jesper Cockx}
%\authornote{with author1 note}          %% \authornote is optional;
                                         %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{%
  \institution{TU Delft}
  \city{Delft}
  \postcode{2628 XE}
  \country{Netherlands}}
\email{j.g.h.cockx@tudelft.nl}           %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}

  Most existing programming languages provide little support to formally
  state and prove properties about programs.  Ad\-ding such capabilities is far
  from trivial, as it requires significant re-engineering of the existing
  compilers and tools.  This paper proposes a novel technique to write
  correct-by-con\-struc\-tion programs in languages without built-in verification
  capabilities, while maintaining the ability to use existing tools.
  This is achieved in three steps.  Firstly, we
  give a shallow embedding of the language (or a subset) into a
  dependently typed language.  Secondly, we write a program
  in that embedding, and we use dependent types to guarantee
  correctness properties of interest.  Thirdly, we
  extract a program written in the original language,
  so that it can be used by the existing compilers and tools.

  Our main insight is that it is possible to
  express all three steps in a single language that supports
  both dependent typ\-es and reflection. Essentially,
  this allows us to express a program, its formal properties, and
  a compiler for it hand-in-hand, offering a lot of flexibility to programmers.
  We demonstrate this three-step approach by embedding a subset of
  the PostScript language in Agda, and illustrating it with several short examples.
  Thus we use the power of reflection to bring the benefits of dependent types to languages
  that had to go without them so far.
\end{abstract}
\maketitle

\section{Introduction}\label{sec:introduction}

It is often desirable to guarantee that a
certain class of errors does not occur in a given program.  These
error classes may include: dereferencing a null pointer, division
by zero, or out of bound indexing.  In most
programming languages, the properties that can be checked
statically are limited.  Nevertheless, moving to a different
language is not always an option.  For example, these languages may
come with great tooling, compilers and/or libraries.  In this paper, we
investigate how to provide strong static guarantees for programs in a
given language, while maintaining the ability to to use existing
compilers and tools.

One powerful method for enforcing almost any functional property of a
program statically is by using \emph{dependent types}, as used for
example in Coq~\cite{Coq-8-13-2} or Agda~\cite{agda-2-6-2}.  In a
dependently typed language, properties can be encoded as types, and if
the program typechecks, the property is guaranteed to hold.  If we
extend our existing language with dependent types (for the verification
part) and then eliminate them (for using the original compiler), then
our goal is achieved.

While it is possible to add dependent types to an existing language
from scratch, doing so is time-consuming and error-prone.  Instead,
we can \emph{embed} the language we want to use into an existing
dependently typed host language, which allows us to re-use the typechecker
of the host language to typecheck the embedded language.

There are two common approaches to language embedding: deep and shallow.
A shallow embedding defines a language in terms of functions and operators
of the host language.  Programs in a shallowly-embedded language are programs
in the host language, so they are immediately run\-nable; types of the embedded
language are types of the host language, so the host typechecker is used for
checking embedded programs.  The downside of this approach is that we cannot
easily get the representation of embedded programs.

Meanwhile, a deep embedding defines a data type to represent the AST
of the embedded language.  This requires us to define a type system
and evaluator for the language separately.  With a dependently typed
host language the AST and the type system can be defined as a single
data structure, which is typically referred to as a tagless
interpreter~\citep{PasalicTS02}.  The benefit of deep embedding is that we get
full access to the syntactic structure of the embedded program.  This
approach works beautifully for embedded languages with simple type
systems. However, for embedded languages with dependent types, tagless
interpreters are technically
possible~\citep{CHAPMAN200921,10.1007/978-3-540-74464-1_7}, but are
extremely challenging to define and use in practice.

The key insight of this paper lies in proposing a novel approach that
combines the best parts of shallow and deep embeddings through the use
of reflection in a
dependently-typed host language such as Coq, Agda, Idris, or Lean.

Our main objective of the paper is to demonstrate that the
proposed approach works in practice.  Therefore, we guide the reader
through the entire process of: i) shallow embedding of the target
language;  ii) writing programs in this embedding; iii) using
dependent types to statically enforce the properties of interest;
iv) extracting a program in the syntax of the target language
from it.  We run the extracted program using existing
tools and libraries. Essentially, we demonstrate that a
shallow embedding in a host language with reflection
suddenly becomes deep.

\input{latex/intro-example}

To keep presentation as easy as possible to follow, we have
chosen a simple target language to embed --- we use a subset
of PostScript~\citep{postscript1999language}, a stack-based
language used in the corresponding document format.
%
\figref{sqsum} shows an example of a program
written in our embedding and the PostScript code produced by
our extractor.
%
While the embedding may look simplistic, this simplicity
allows us to focus on the essence of the proposed approach and avoid unrelated
technical details.  We ensure that many verification patterns found in bigger
languages are covered, showing that the proposed approach scales.

This entire paper is a literate Agda script: all code is typechecked
while generating the paper.


\paragraph{Contributions.}
\begin{itemize}

\item We propose a novel approach that can be used to statically
  enforce almost any property of programs in an existing language, by
  embedding it in a host language that supports dependent types and
  reflection.

\item We demonstrate this approach by a concrete example: an embedding
  of a subset of the PostScript language into Agda
  (\secref{embedding}). We give several examples of PostScript
  programs written in our embedding, and demonstrate how to statically
  enforce properties such as the absence of stack underflows,
  termination, and functional correctness.

\item We show how to use reflection in Agda to implement an extractor
  that translates code written in our embedding to plain PostScript
  (\secref{extraction}).

\item We show how to our approach provides easy support for partial
  evaluation by making use of normalisation in the host language. This
  allows us to use functions of the host language as macros, as well
  as automatically apply optimizations through the use of rewrite
  rules (\secref{partial-evaluation}).
\end{itemize}

\begin{comment}
The rest of this paper is structured as follows. \secref{background}
provides background information on Agda and its reflection
capabilities. \secref{embedding} describes our embedding of PostScript
in Agda, and gives several examples of programs written in
it. \secref{extraction} shows how to implement an extractor for this
embedding using reflection. Next, \secref{partial-evaluation}
demonstrates how to apply partial evaluation to programs prior to
extraction by using Agda's normalisation procedure. Finally,
\secref{related} discusses related work and \secref{conclusion}
concludes.
\end{comment}

\begin{comment}
\todo[inline]{Move it somewhere}
This picture has been generated by the code that was extracted from our
Agda embedding.

\begin{center}
\epsfbox[0 0 64 64]{sierp.ps}
\end{center}
\end{comment}

% Right now we have the following plan about the structure of the GPCE paper.
% \begin{enumerate}
%     \item Goal: implementing DSL with dependent type system
%     \item Problem: current two approaches are either doing a deep embedding or
%         implementing a typechecker from scratch
%     \item Reflection to the rescue: we can use reflection for implementing
%         custom compilers
%     \item Our approach by example: demonstrate that this actually works in Agda
%         (ps example)
%     \item Extracting definitions by pattern matching: matching on the stack
%     \item Using normalization to get rid of meta-functions (by using this
%         technique, you get macros for free! / or use rewrite rules example:
%         exchange o exchange = id)
%     \item General technology for writing extractors
%     \item This actually scales to realistic and useful examples!
% \end{enumerate}
%
% Optional parts:
% \begin{enumerate}
%     \item Generating assertions
%     \item Ensuring termination of recursive functions
% \end{enumerate}

% Agda Basics and Extraction
\input{latex/background}
\input{latex/psembedding}
\input{latex/extraction}
\input{latex/reduction}

\section{\label{sec:related}Related Work}

%\paragraph{Metaprogramming}
There is a large body of
work on metaprogramming facilities in various programming
languages.  \citet{refl-masses} track the origins
of metaprogramming to Smith's work on reflection in Lisp \cite{refl-lisp}.
Some prominent metaprogramming systems include
MetaOCaml \cite{metaocaml}, Me\-taML \cite{metaml},
reFlect \cite{DBLP:journals/jfp/GrundyMO06},
Template Haskell \cite{sheard2002template},
Racket \cite{plt-tr1}, and various other Lisp/Scheme dialects.
%
However, these systems typically do not support dependent
types, so they are not well suited for our goal of statically
enforcing correctness of embedded programs.

%\paragraph{Embedding}
Defining deep embeddings with static guarantees are a common application
of dependent types~\cite{10.5555/647849.737066,CHAPMAN200921,
10.1007/978-3-540-74464-1_7,10.1145/3236785,10.1145/1863495.1863497}.
%
These embeddings usually also define semantics of the embedded
language and therefore allow us to reason about the correctness
of program transformations and optimisations.
%
While the fact that this is possible is impressive in theory, the resulting
encodings are often difficult to use in practice. In this paper
we instead aim for a more lightweight approach.
%
\citet{deepshallow} propose to solve this problem with
a combination of deep and shallow embeddings.  Their idea is to define
a small deep embedding and leverage type classes in Haskell to define
the rest of the language on top of that.  However, so far this idea has not yet
been applied to dependently typed embedded languages.


%\paragraph{Extraction}
The Coq proof assistant is equipped with extraction
capabilities~\cite{10.1007/978-3-540-69407-6_39,10.1007/3-540-39185-1_12},
which extracts functional code from Coq proofs (or programs).  The
default target language is OCaml, but a few other options were added
recently.
%
Likewise, Agda itself has a mechanism for defining custom backends, of
which the GHC backend is the most prominent.
%
Other proof assistants provide similar extraction tools as well.
%
The main difference from our approach in this paper
is that these extractors are written as plugins to the proof
assistant, while we implement our extractors directly in the proof
assistant itself.
%
While it would be possible to implement extractors presented in this
paper as Coq plugins or Agda backends, conceptually they are more
heavyweight.  Our extractors and programs can (in principle)
communicate with each other. In addition, as they are just Agda programs, they can
be reflected themselves and their structure can be leveraged.


%\paragraph{Dependently typed metaprogramming}
Several dependently-typed languages are equipped with metaprogramming
capabilities: Idris \cite{idris-refl}, Lean \cite{lean-refl},
Coq \cite{metacoq}, and Agda \cite{agda-refl}.  All of these
implement a similar API as described in this paper.  This is
reassuring, as it means our proposed approach is immediately portable
into many other contexts.
\citet{10.1145/3371071} introduce the Turnstile+ framework for
building dependently typed embedded DSLs and
shares the ideas advocated in this paper, suggesting that
our approach could work there as well.
\citet{10.1145/3371076} use MetaCoq to formally verify
the core type system of Coq. This combines nicely with
our approach, as we could use the verified core language
as a basis to verify our custom extractors.
\citet{10.1145/3372885.3373829} use MetaCoq to implement
a DSL combining deep and shallow approaches, in a way that
is quite similar to our own. While they are able to formally
reason about preservation of semantics (which we cannot do yet), it is unclear
whether their approach scales to dependently-typed embedded languages.

\section{Conclusions and Future Work} \label{sec:conclusion}


In this paper we investigate the idea of developing
embedded programs hand-in-hand with custom
code generators for them. We solve the well-known
conundrum of choosing between deep and shallow
embedding by leveraging the power of
reflection.
This allows us to enjoy simplicity of writing programs
in shallow embedding.  Yet we keep full access to the internal
structure of the embedded programs, so that we could translate
them into the original language.

We apply this idea in the context of dependently-typed
language Agda.  We demonstrate the use of dependent types
to enforce static properties of the embedded programs.
Concretely, we have demonstrated the approach by implementing
an extractor for a fragment of the PostScript language.

The main advantage of our approach is twofold: first, it allows
you to implement all these things --- as well as the embedded programs
themselves --- \emph{side by side in a single language}, simplifying
the development. And secondly, it allows you to reuse the typechecker
and evaluator of the host language, saving you a lot of work.
While we showcase a single example, the approach has been applied
to several other languages: Kaleidoscope, a minimalist imperative language;
Single assignment C, a high-performance array language; and
APL (Array Programming Language), another array language with
heavily overloaded syntax.
For more details on these examples,
refer to~\citet{DBLP:journals/corr/abs-2105-10819}.

We believe that the reader is now empowered to apply the proposed
technique to verify code in any language.



\paragraph{Future work}
While our approach is flexible and powerful, it is
certainly not a magic bullet. A lot of things
need to be implemented for each target language: the embedding,
the encoding of the properties under consideration as types,
and the extractor.  For enforcing more complex properties, a number
of proofs needs to be written explicitly.

Right now, we cannot yet guarantee that the
extracted code preservers the semantics of the original
implementation. While we rarely see
fully-verified compiler backends in the real world,
our approach is very close to enabling this.
We would need a formal semantics of the reflected language
and the proof that reflected programs respect it.
While this is non-trivial, a system like Agda could do
this in principle.

% There is a number of improvements that can be added to
% Agda and our extractors to make the resulting code more
% efficient.  Supporting \AK{let}s in the internal syntax
% would help to preserve sharing.  Recognising irrelevance
% annotations in the extractors would help to eliminate
% unused function arguments.  Introducing proper language
% primitives to specify what exactly is an embedding would
% be helpful. And finally, having access to more of
% Agda's internals such as case trees would help to
% generate more performant code.
%
% Overall, this work only scratches the surface of extraction-based
% compilation.  We never considered alternative theories supported
% by theorem provers, \eg{} cubical type theory in Agda; we did not
% consider recursive metaprogramming; we did not consider integrating
% optimisations of extracted programs other than what rewriting rules
% are capable to do.  All of these offer exciting research opportunities
% on the way to make verified software easily accessible.
% To paraphrase Jim Morrison: ``Safety and no surprise, The End''.

\begin{acks}
We would like to thank reviewers for their constructive suggestions.
This work is supported by the \grantsponsor{EPSRC}{Engineering and Physical
Sciences Research Council}{https://epsrc.ukri.org} through the grant
\grantnum{EPSRC001}{EP/N028201/1}.
\end{acks}

\pagebreak
%% Bibliography
\bibliography{paper}


\end{document}
