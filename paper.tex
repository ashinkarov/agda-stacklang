\documentclass[sigplan,anonymous,review]{acmart}

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}

\citestyle{acmauthoryear}   %% For author/year citations



%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

% Add definitions for abbreviations like e.g.; i.e; etc. with
% correct spacing depending on the parameters.  In this case
% `all' exposes all the definitions of the package, and `british'
% makes sure that there is no comma after e.g. or i.e.
\usepackage[all,british]{foreign}

\usepackage{epsf}

\usepackage{mathpartir}

\usepackage{todonotes}

\usepackage{varwidth}
\usepackage{microtype}

\usepackage{agda}
\usepackage{newunicodechar}
\usepackage[final]{listings}

%\usepackage[T1]{fontenc}

\newunicodechar{∷}{::}
\newunicodechar{→}{\ensuremath{\to}}
\newunicodechar{ω}{\ensuremath{\omega}}
\newunicodechar{⊎}{\ensuremath{\uplus}}
\newunicodechar{≔}{\ensuremath{\coloneqq}}
\newunicodechar{∎}{\ensuremath{\blacksquare}}
\newunicodechar{≟}{\ensuremath{\stackrel{?}{=}}}
\newunicodechar{ᵣ}{\ensuremath{_r}}
\newunicodechar{ₗ}{\ensuremath{_l}}
\newunicodechar{▴}{\ensuremath{\blacktriangle}}
\newunicodechar{▾}{\ensuremath{\blacktriangledown}}
\newunicodechar{▹}{\ensuremath{\triangleright}}
\newunicodechar{∸}{\ensuremath{\dot{-}}}
\newunicodechar{⊛}{\ensuremath{\circledast}}
\newunicodechar{ᵀ}{\ensuremath{{}^{\text{T}}}}
\newunicodechar{⌿}{\ensuremath{\not-}}

\newunicodechar{←}{\ensuremath{\leftarrow}}
\newunicodechar{×}{\ensuremath{\times}}
\newunicodechar{λ}{\ensuremath{\lambda}}
\newunicodechar{∀}{\ensuremath{\forall}}
\newunicodechar{Π}{\ensuremath{\Pi}}
\newunicodechar{≡}{\ensuremath{\equiv}}
\newunicodechar{≅}{\ensuremath{\cong}}
\newunicodechar{≐}{\ensuremath{\doteq}}
\newunicodechar{∈}{\ensuremath{\in}}
\newunicodechar{∧}{\ensuremath{\land}}
\newunicodechar{∨}{\ensuremath{\lor}}
\newunicodechar{⊤}{\ensuremath{\top}}
\newunicodechar{⊥}{\ensuremath{\bot}}
\newunicodechar{⊔}{\ensuremath{\sqcup}}
\newunicodechar{∷}{\ensuremath{{::}}}
\newunicodechar{ℓ}{\ensuremath{\ell}}
\newunicodechar{₀}{\ensuremath{{_0}}}
\newunicodechar{₁}{\ensuremath{{_1}}}
\newunicodechar{₂}{\ensuremath{{_2}}}
\newunicodechar{₃}{\ensuremath{{_3}}}
\newunicodechar{₄}{\ensuremath{{_4}}}
\newunicodechar{₅}{\ensuremath{{_5}}}
\newunicodechar{₆}{\ensuremath{{_6}}}
\newunicodechar{₇}{\ensuremath{{_7}}}
\newunicodechar{₈}{\ensuremath{{_8}}}
\newunicodechar{₉}{\ensuremath{{_9}}}
\newunicodechar{⟨}{\ensuremath{{\langle}}}
\newunicodechar{⟩}{\ensuremath{{\rangle}}}
\newunicodechar{̧}{\c}
\newunicodechar{≤}{\ensuremath{\leq}}
\newunicodechar{ℕ}{\ensuremath{\mathbb{N}}}
\newunicodechar{∸}{̣\ensuremath{-}}
\newunicodechar{ᵇ}{\ensuremath{{}^{b}}}


% Some shortcut commands for agda symbols
\newcommand{\AD}[1]{\AgdaDatatype{#1}}
\newcommand{\AC}[1]{\AgdaInductiveConstructor{#1}}
\newcommand{\AF}[1]{\AgdaFunction{#1}}
\newcommand{\AB}[1]{\AgdaBound{#1}}
\newcommand{\AK}[1]{\AgdaKeyword{#1}}
\newcommand{\AR}[1]{\AgdaField{#1}}
\newcommand{\AM}[1]{\AgdaModule{#1}}
\newcommand{\AN}[1]{\AgdaNumber{#1}}
\newcommand{\AS}[1]{\AgdaString{#1}}

\newcommand\codeblock[1]{%
  %{\fbox{\begin{varwidth}{0.9\textwidth}#1\end{varwidth}}}
  {\begin{varwidth}{0.9\textwidth}#1\end{varwidth}}
}


\begin{document}

%% Title information
\title[]{Extracting The Power of Dependent Types}


%% Author with single affiliation.
\author[A. {\v{S}}inkarovs]{Artjoms {\v{S}}inkarovs}
\orcid{0000-0003-3292-2985}
%\authornote{with author1 note}          %% \authornote is optional;
                                         %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{%
  \institution{Heriot-Watt University}   %% \institution is required
  \city{Edinburgh}
  \state{Scotland}
  \postcode{EH14 4AS}
  \country{UK}}
\email{a.sinkarovs@hw.ac.uk}             %% \email is recommended


%% Author with single affiliation.
\author[J. Cockx]{Jesper Cockx}
%\authornote{with author1 note}          %% \authornote is optional;
                                         %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{%
  \institution{TU Delft}
  \city{Delft}
  \postcode{2628 XE}
  \country{Netherlands}}
\email{j.g.h.cockx@tudelft.nl}           %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}

  Most existing programming languages provide little support to formally
  state and prove properties about programs.  Adding such capabilities is far
  from trivial, as it requires significant re-engineering of the existing
  compilers and tools.  This paper proposes a novel technique to write
  correct-by-construction programs in languages without built-in verification
  capabilities, maintaining the ability to use existing tools.
  This is achieved in three steps.  Firstly, we
  give a shallow embedding of the language (or a subset) into a
  dependently typed language.  Secondly, we write a program
  in that embedding, and we use dependent types to guarantee
  correctness properties of interest.  Thirdly, we
  translate the embedded program back into the original language,
  so that it can be used by the existing compilers and tools.

  Our main insight is that it is possible to
  express all three steps in a single language, as long as it supports
  both dependent types and reflection. Essentially,
  this allows us to express a program, its formal properties, and
  a compiler for it hand-in-hand, offering a lot of flexibility to programmers.
  We demonstrate this three-step approach by embedding a subset of
  the PostScript language in Agda, and illustrating it with several short examples.
  Thus we use the power of reflection to bring the benefits of dependent types to languages
  that had to go without them so far.


%  Dependently-typed host languages empower users to verify a wide
%  range of properties of embedded languages and
%  programs written in them.  Designers of such embedded languages
%  are faced with a difficult choice between using a shallow or a deep
%  embedding.  The former is easier to use because the entire
%  infrastructure of the host langauge is immediately
%  available. Meanwhile, the latter gives full access to the
%  structure of embedded programs, but is difficult to use in practice,
%  especially when the embedded language is itself dependently typed.
%
%  The main insight presented in this paper is that the choice between
%  shallow and deep embedding can be eliminated by working in a host
%  language with reflection capabilities: we start from a shallow
%  embedding that can use all libraries and tools of the host language,
%  and later use reflection to expose the deep structure of the
%  embedded programs.
%  %
%  Concretely, we apply this technique to embed three
%  programming languages --- Kaleidoscope, SaC, and (a subset of) APL ---
%  into the dependently typed theorem prover Agda, using dependent
%  types to statically enforce several properties of interest.  We then
%  use Agda's reflection capabilities to extract the embedded programs
%  back into the original language, so that the existing toolchain can
%  be leveraged.
%  %
%  In this process, statically verified properties of the host language
%  are mapped onto runtime checks in the target language, allowing
%  extracted programs to interact safely with existing code.
%  %
%  Finally, we demonstrate the feasibility of our approach with the
%  implementation and extraction of a convolutional neural network in
%  our embedding of APL.\@

%  Most practical programming languages of today prioriterise
%  performance and usability over safety.  As a result, many
%  useful correctness invariants cannot be expressed in the given
%  language, typically due to weakness of the chosen type system.
%  We are looking for non-invasive verification: how to
%  guarantee a property about the given program without any modifications
%  to the language toolchain.
%
%  We study an approach when a programming language is shallowly
%  embedded into a theorem prover, and dependent types are used
%  to encode the properties of interest.   Bringing the embedded
%  langauge and the properties back into the original language
%  is the main focus of this work.  We propose a generic extraction
%  mechanism that we implement in Agda that is based on the concept
%  of reflection.  Making it possible to translate any shallowly
%  embedded language in the target backend without the necessity
%  to modify the theorem prover.
%  We demonstrate our framework in action by encoding three languages:
%  Kaleidoskope, SaC and a subset of APL, culminating in the implementation
%  and extraction of a convolutional neural network.
\end{abstract}
\maketitle

\section{Introduction}



It is often desirable to guarantee that a certain class of errors does
not occur in the given program.  For example, the program can never dereference
a null pointer; or division by zero never occurs; or indexing is always
within bounds.  In practical programming languages, the kind of guarantees
that we can provide formally is typically very limited.  At the same time,
there could be many arguments in favour of keeping using these languages.
For example they may come with great tooling, compilers and libraries.
Therefore, the problem we are investigating in this paper is how to
provide formal guarantees for the program in some language, yet being
able to use the original compilers and tools.

One way to tackle this problem is via rephrasing it in terms
of dependent types.  If the language of interest were to support dependent
types, we could encode any property about the given program in
types.  Then, if the program typechecks, the property holds automatically.
So, the question now becomes how can we add dependent types to a language
(for verification part), and then eliminate them (for using the original
compiler).

While implementing a custom typechecker from scratch for a
dependently-typed language is possible, it is time-consuming and error-prone.
Alternatively, one can reuse existing implementations of dependently-type
systems by means of embedding.  In this case, we can share the type system
of the host language to typecheck the embedded language.

There are two common approaches to language embedding: deep and shallow.
Shallow embedding defines a language in terms of functions and operators
of the host language.  Programs in a shallowly-embedded language are programs
in the host language, so they are immediately runnable; types of the embedded
language are types of the host language, so the host typechecker is used for
checking embedded programs.  The downside of this approach is that we cannot
easily get the representation of the embedded program.

Deep embedding defines a data type to represent the AST of the embedded language.
Then we need to define a type system and evaluator for the language separately.
With a dependently-typed host language the AST and the type system can be
defined within a single data structure, which is typically referred as
tagless interpreters~\cite{}.  The benefit of deep embedding is that we
get immediate access to the structure of the embedded program.
The approach works beautifully for
embedded languages with simple type systems.  If the language we want to
embed is dependently-typed, it is shown~\cite{} to be possible, but the
resulting embedding is very difficult to use in practice.

Our solution to this problem is to rely on a reflection mechanism that
can be found in dependently-typed systems such as Idris, Agda, Lean.
Reflection makes it possible to obtain a representation of the
given term of the host language.  Essentially, shallow embedding in
a host language with reflections suddenly becomes deep.

In this paper we demonstrate that the proposed approach is actually possible
by example.  We embed a subset of PostScript~\cite{}, which is a stack-based
language used in the corresponding document format.  Simplicity of the language
allows us to focus on the essence of the proposed approach and avoid unrelated
technical details.  We use Agda as our host language, and we demonstrate the
embedding, how to specify a program, and most importantly, program extraction.

\todo[inline]{Should we talk about using rewrites as an optimisation?
        Should we talk here about scaling to realistic examples?
        Should we mention our work on extending Agda?}
\todo[inline]{Technical contributions}

% Right now we have the following plan about the structure of the GPCE paper.
% \begin{enumerate}
%     \item Goal: implementing DSL with dependent type system
%     \item Problem: current two approaches are either doing a deep embedding or
%         implementing a typechecker from scratch
%     \item Reflection to the rescue: we can use reflection for implementing
%         custom compilers
%     \item Our approach by example: demonstrate that this actually works in Agda
%         (ps example)
%     \item Extracting definitions by pattern matching: matching on the stack
%     \item Using normalization to get rid of meta-functions (by using this
%         technique, you get macros for free! / or use rewrite rules example:
%         exchange o exchange = id)
%     \item General technology for writing extractors
%     \item This actually scales to realistic and useful examples!
% \end{enumerate}
%
% Optional parts:
% \begin{enumerate}
%     \item Generating assertions
%     \item Ensuring termination of recursive functions
% \end{enumerate}

% Agda Basics and Extraction
\input{latex/background}
\input{latex/psembedding}
\input{latex/extraction}
\input{latex/reduction}


\section{Scaling to Bigger Langauges}
Not sure whether this deserves a separate section, but we need to explain
that the proposed technology perfectly scales to the level of bigger (more complex)
languages.


\section{Related Work}

\section{Conclusios and Future Work}

%% Bibliography
\bibliography{paper}


\end{document}
